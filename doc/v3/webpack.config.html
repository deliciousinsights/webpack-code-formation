<!DOCTYPE html><html lang="en"><head><title>v3/webpack.config</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../"><meta name="groc-document-path" content="v3/webpack.config"><meta name="groc-project-path" content="v3/webpack.config.js"><link rel="stylesheet" type="text/css" media="all" href="../assets/style.css"><script type="text/javascript" src="../assets/behavior.js"></script><body><div id="meta"><div class="file-path">v3/webpack.config.js</div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><h1 id="webpack-v3-configuration-principale">Webpack v3 - Configuration principale</h1></div></div></div><div class="segment"><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> merge = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack-merge'</span>)
<span class="hljs-keyword">const</span> parts = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./webpack.config.parts'</span>)
<span class="hljs-keyword">const</span> Path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="chemins-principaux">Chemins principaux</h2></div></div></div><div class="segment"><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> PATHS = {
  build: Path.resolve(__dirname, <span class="hljs-string">'dist'</span>),</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Les entries peuvent être relatives, mais au CWD, alors autant forcer
l’absolu par rapport au fichier de config.</p></div></div><div class="code"><div class="wrapper">  source: Path.resolve(__dirname, <span class="hljs-string">'src'</span>),
  static: Path.resolve(__dirname, <span class="hljs-string">'static'</span>),
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="config-partage-devprod">Config partagée dev/prod</h2></div></div></div><div class="segment"><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> coreConfig = merge(
  {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Point d’entrée de l’application. En utilisant un objet, on facilite
l’extraction d’autres entrées auto (type vendor).</p></div></div><div class="code"><div class="wrapper">    entry: { main: [PATHS.source] },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Sortie produite par le build.</p></div></div><div class="code"><div class="wrapper">    output: {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Format des URLs de fichiers d’origine dans les source maps.  On vire le
<code>?query</code> par défaut, qui est moche et ne sert à rien</p></div></div><div class="code"><div class="wrapper">      devtoolModuleFilenameTemplate: <span class="hljs-string">'webpack:///[resource-path]'</span>,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Schéma des noms de fichiers bundles. Le <code>[name]</code> sera remplacé par le
nom du bundle, basé sur celui de l’entrée (ex. <code>main</code>). Ce nom peut
contenir des chemins au début, le tout relatif à <code>output.path</code>.</p>
<p>L’option <code>filename</code> est utilisée pour les <em>entry chunks</em>, la
<code>chunkFilename</code> pour les <em>async chunks</em>.</p></div></div><div class="code"><div class="wrapper">      chunkFilename: <span class="hljs-string">'[name].js'</span>,
      filename: <span class="hljs-string">'[name].js'</span>,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Chemin absolu racine de production des fichiers bundlés.</p></div></div><div class="code"><div class="wrapper">      path: PATHS.build,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Préfixe de chemin des URLs pour les fichiers produits.  Ici, on est
« racine domaine », mais si on prévoit un déploiement (dev ou prod)
dans un sous-chemin, il est impératif de le caler ici.</p></div></div><div class="code"><div class="wrapper">      publicPath: <span class="hljs-string">'/'</span>,
    },
  },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>On utilise des source maps ; par défaut ici, on sera en <code>eval-source-map</code>,
qui a ceci de mieux que le <code>eval</code> de base qu’il utilise le source
d’origine, pas le transpilé / transformé.</p></div></div><div class="code"><div class="wrapper">  parts.generateSourceMaps(),</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Passage des JS/JSX à travers Babel, par défaut en <code>preset-env</code> sans
transpilation de modules, pour que Webpack puisse faire ses optims majeures
(<em>tree shaking</em>, <em>scope hoisting</em>).  On limite à nos propres sources, pour
aller plus vite</p></div></div><div class="code"><div class="wrapper">  parts.babelize({ include: PATHS.source }),</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Annulation du bundling par défaut de tous les locales Moment en raison du
require dynamique (<code>require(&#39;./locale/&#39; + locale)</code>) dans son code source.
On s’économise bien 50Ko min+gz.</p></div></div><div class="code"><div class="wrapper">  parts.ignoreMomentLocales(),</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>ESLint sur nos propres JS, intégré au build : ça remontera notamment dans
l’overlay.</p></div></div><div class="code"><div class="wrapper">  parts.lintJS({ include: PATHS.source }),</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Copie récursivement le(s) répertoire(s) passé(s) dans le dossier de
destination.</p></div></div><div class="code"><div class="wrapper">  parts.copyStatic(PATHS.static),</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Extraction automatique des modules venant de npm/<code>node_modules</code> dans un
chunk unique <code>vendor</code>.  C’est un peu le service minimum, mais ce n’est pas
100% optimal pour autant. Webpack 4, avec sa stratégie automatique, va plus
loin (mais en prod seulement).  Le faire en dev permet de considérablement
réduire les builds incrémentaux.  On en profite aussi pour extraire la
<em>runtime</em> Webpack dans un bundle à part, afin d’éviter la modification de
hashes par effet de bord dans des bundles non concernés.</p></div></div><div class="code"><div class="wrapper">  parts.autoVendor(),</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Prise en compte des assets images, avec inlining auto si inférieures à
10Ko.</p></div></div><div class="code"><div class="wrapper">  parts.loadImages(),</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Prise en compte des assets webfonts, avec inlining auto si inférieures à
10Ko.</p></div></div><div class="code"><div class="wrapper">  parts.loadFonts(),</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Génération et maintenance auto du <code>index.html</code>, avec les bonnes balises
<code>&lt;script&gt;</code> et <code>&lt;link rel=&quot;styleheet&quot;/&gt;</code></p></div></div><div class="code"><div class="wrapper">  parts.html({ title: <span class="hljs-string">'Webpack 3 - Premiers Pas'</span> }),</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Pas de production de fichiers à jour si 1+ asset a un problème</p></div></div><div class="code"><div class="wrapper">  parts.safeAssets(),</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Activation du cache HardDisk, sans doute l’œpti la plus impactante pour le
dev comme pour la prod, qui permet d’éviter d’avoir à en mettre en œuvre
plein d’autres (HappyPack, Dll/DllReference…) tant qu’on n’atteint pas des
builds pharaoniques.</p></div></div><div class="code"><div class="wrapper">  parts.useModuleLevelCache()
)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="config-complmentaire-de-dev">Config complémentaire de dev</h2></div></div></div><div class="segment"><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> devConfig = () =&gt;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Le <code>merge.smart</code> devrait en fait être le mode par défaut : il fusionne
intelligemment les pipelines de loaders, à clé (ex. <code>test</code>) égale.</p></div></div><div class="code"><div class="wrapper">  merge.smart(
    coreConfig,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Personnalisation du Webpack-Dev-Server lancé en dev…</p></div></div><div class="code"><div class="wrapper">    parts.devServer({</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>…port personnalisé (par défaut 8080)</p></div></div><div class="code"><div class="wrapper">      port: <span class="hljs-number">3003</span>,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>…démo proxy (pour avoir un seul port frontal en dépit de couches
backend distinctes qui produisent le HTML, les réponses API, etc.).</p></div></div><div class="code"><div class="wrapper">      proxy: {
        <span class="hljs-string">'/api'</span>: {
          target: <span class="hljs-string">'https://jsonplaceholder.typicode.com'</span>,
          pathRewrite: { <span class="hljs-string">'^/api'</span>: <span class="hljs-string">''</span> },
          changeOrigin: <span class="hljs-literal">true</span>,
        },
      },
    }),</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Webpack-Dashboard ; sympa pour superviser le build et ses contenus</p></div></div><div class="code"><div class="wrapper">    parts.dashboard(),</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Chargement à la volée des CSS ; PostCSS+cssnext est là de base, et on
active les CSS Modules au niveau du <code>css-loader</code>.</p></div></div><div class="code"><div class="wrapper">    parts.loadCSS({ modules: <span class="hljs-literal">true</span> }),</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Idem, mais avec la transpilation SASS en début de pipeline (SASS3 :
extension <code>.scss</code>).</p></div></div><div class="code"><div class="wrapper">    parts.loadSASS({ modules: <span class="hljs-literal">true</span> })
  )</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="config-complmentaire-de-prod">Config complémentaire de prod</h2></div></div></div><div class="segment"><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> prodConfig = () =&gt;
  merge.smart(</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Nettoyage du dossier cible (<code>dist/</code>), vu qu’avec les hashes dans les noms
de fichiers, ceux-ci vont potentiellement changer d’un build à l’autre.</p></div></div><div class="code"><div class="wrapper">    parts.cleanDist([PATHS.build]),
    coreConfig,
    {
      output: {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>On ajoute un hash court (basé MD5 par défaut) aux noms de fichiers
pour améliorer leur mise en cache (<em>Long-Term Caching</em>) au moyen
d’expirations très longues.</p>
<p>L’option <code>filename</code> est utilisée pour les <em>entry chunks</em>, la
<code>chunkFilename</code> pour les <em>async chunks</em>.</p></div></div><div class="code"><div class="wrapper">        chunkFilename: <span class="hljs-string">'[name].[chunkhash:8].js'</span>,
        filename: <span class="hljs-string">'[name].[chunkhash:8].js'</span>,
      },
    },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Changement du type de source maps pour les mettre dans des fichiers à
part, et avec le plus fort niveau de détail possible.</p></div></div><div class="code"><div class="wrapper">    parts.generateSourceMaps({ type: <span class="hljs-string">'source-map'</span> }),</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>On permet l’analyse statique des conditions basées sur
<code>process.env.NODE_ENV</code>, afin que les minifieurs (notamment JS, donc
UglifyJS) puissent considérer ces blocs comme du code mort le cas
échéant, et donc les éliminer (<em>Dead Code Elimination</em>, DCE).</p></div></div><div class="code"><div class="wrapper">    parts.makeNonProductionCodeStrippable(),</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><em>Scope hoisting</em>, lorsque c’est possible, sur les modules ES.</p></div></div><div class="code"><div class="wrapper">    parts.concatenateModules(),</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Extraction dans des fichiers à part des CSS, d’où qu’elles viennent.</p></div></div><div class="code"><div class="wrapper">    parts.extractCSS({ modules: <span class="hljs-literal">true</span> }),
    parts.extractSASS({ modules: <span class="hljs-literal">true</span> }),</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Minification du JS et des CSS</p></div></div><div class="code"><div class="wrapper">    parts.minifyAll(),</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Optimisation des images (utilise <code>imagemin</code> en interne, opère aussi bien
sur les JPEG que sur les PNG, GIF, WEBP et SVG).</p></div></div><div class="code"><div class="wrapper">    parts.optimizeImages(),</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Pré-compression (<code>.gz</code> basée Zopfli) des fichiers textuels (HTML, CSS,
JS, SVG) et des PNG (basée Zopfli, sans extension complémentaire).</p></div></div><div class="code"><div class="wrapper">    parts.compressFiles(),</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Inlining du <em>runtime chunk</em> (extrait par notre <code>autoVendor()</code> dans la
config commune) directement dans le HTML, pour s’économiser une requête
HTTP (la runtime est très, très inférieure à 30Ko, le jeu en vaut donc la
chandelle).</p></div></div><div class="code"><div class="wrapper">    parts.inlineRuntime(),</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Publier le manifeste des assets et de leurs versions « fingerprintées »,
pour exploitation potentielle par de la génération tierce de HTML.</p></div></div><div class="code"><div class="wrapper">    parts.publishManifest(),</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Si l’environnement demande l’activation de Webpack Monitor, on l’ajoute
(voir nos scripts dans <code>package.json</code>)</p></div></div><div class="code"><div class="wrapper">    process.env.WEBPACK_MONITOR === <span class="hljs-string">'true'</span> ? parts.monitor() : <span class="hljs-literal">undefined</span>
  )</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>On exporte une fonction : elle recevra en argument la valeur composée à
partir des arguments <code>--env</code> de la CLI ; on n’en passe pas, donc à défaut
elle prend le <code>process.env.NODE_ENV</code> en vigueur et renvoie la config
appropriée.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-built_in">module</span>.exports = (env = process.env.NODE_ENV) =&gt;
  env === <span class="hljs-string">'production'</span> ? prodConfig() : devConfig()</div></div></div></div></body></html>